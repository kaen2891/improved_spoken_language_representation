import sys, os 


import pandas as pd
from glob import glob

import os, sys
import numpy as np

def _levenshtein_distance(ref, hyp):
    m = len(ref)
    n = len(hyp)

    if ref == hyp:
        return 0
    if m == 0:
        return n
    if n == 0:
        return m

    if m < n:
        ref, hyp = hyp, ref
        m, n = n, m

    distance = np.zeros((2, n + 1), dtype=np.int32)

    for j in range(0,n + 1):
        distance[0][j] = j

    for i in range(1, m + 1):
        prev_row_idx = (i - 1) % 2
        cur_row_idx = i % 2
        distance[cur_row_idx][0] = i
        for j in range(1, n + 1):
            if ref[i - 1] == hyp[j - 1]:
                distance[cur_row_idx][j] = distance[prev_row_idx][j - 1]
            else:
                s_num = distance[prev_row_idx][j - 1] + 1
                i_num = distance[cur_row_idx][j - 1] + 1
                d_num = distance[prev_row_idx][j] + 1
                distance[cur_row_idx][j] = min(s_num, i_num, d_num)

    return distance[m % 2][n]

def cer(reference, hypothesis):
    

    reference = reference.lower()
    hypothesis = hypothesis.lower()

    edit_distance = _levenshtein_distance(reference, hypothesis)
    ref_len = len(reference)

    if ref_len == 0:
        raise ValueError("Length of reference should be greater than 0.")

    cer = float(edit_distance) / ref_len
    return cer

def wer(reference, hypothesis, delimiter=' '):
    

    reference = reference.lower()
    
    hypothesis = hypothesis.lower()

    ref_words = reference.split(delimiter)
    hyp_words = hypothesis.split(delimiter)
    
    #print(ref_words, hyp_words)
    
    #exit()

    edit_distance = _levenshtein_distance(ref_words, hyp_words)

    edit_distance = float(edit_distance)
    ref_len = len(ref_words)

    if ref_len == 0:
        raise ValueError("Reference's word number should be greater than 0.")

    wer = float(edit_distance) / ref_len
    return wer


################################

def read_data(files, name):  
    data = pd.read_csv(files).dropna()
    name_input = '{}_sentence'.format(name)
    label_sentence = data['train_sentence'].values.tolist()
    stt_sentence = data[name_input].values.tolist()
    return label_sentence, stt_sentence

def read_data_valid(files, name):  
    data = pd.read_csv(files).dropna()
    name_input = '{}_sentence'.format(name)
    label_sentence = data['valid_sentence'].values.tolist()
    stt_sentence = data[name_input].values.tolist()
    return label_sentence, stt_sentence

def read_data_test(files, name):  
    data = pd.read_csv(files).dropna()
    name_input = '{}_sentence'.format(name)
    label_sentence = data['test_sentence'].values.tolist()
    stt_sentence = data[name_input].values.tolist()
    return label_sentence, stt_sentence

import re
#string = re.sub("\!|\'|\?","",string)

def measuring_train(files, speaker):
    label, stt = read_data(files, speaker)
    
    wer_res = 0.0
    cer_res = 0.0
    
    for i in range(len(label)):
        label[i] = re.sub("\!|\.|\?","",label[i])
        wer_res += wer(label[i], stt[i])
        cer_res += cer(label[i], stt[i])
    wer_res /= (i+1)
    cer_res /= (i+1)
    
    return wer_res * 100.0, cer_res * 100.0

def measuring_valid(files, speaker):
    label, stt = read_data_valid(files, speaker)
    
    wer_res = 0.0
    cer_res = 0.0
    
    for i in range(len(label)):
        label[i] = re.sub("\!|\.|\?","",label[i])
        wer_res += wer(label[i], stt[i])
        cer_res += cer(label[i], stt[i])
    wer_res /= (i+1)
    cer_res /= (i+1)
    
    return wer_res * 100.0, cer_res * 100.0

def measuring_test(files, speaker):
    label, stt = read_data_test(files, speaker)
    
    wer_res = 0.0
    cer_res = 0.0
    
    for i in range(len(label)):
        label[i] = re.sub("\!|\.|\?","",label[i])
        wer_res += wer(label[i], stt[i])
        cer_res += cer(label[i], stt[i])
    wer_res /= (i+1)
    cer_res /= (i+1)
    
    return wer_res * 100.0, cer_res * 100.0

def get_res(train, valid, test, speaker):
    train_cer, train_wer = measuring_train(train, speaker)
    valid_cer, valid_wer = measuring_valid(valid, speaker)
    test_cer, test_wer = measuring_test(test, speaker)
    
    print(speaker, train_cer, valid_cer, test_cer)
    print(speaker, train_wer, valid_wer, test_wer)
    
    return speaker, train_cer, valid_cer, test_cer, train_wer, valid_wer, test_wer
    
    

all_train = sorted(glob('./*_train.csv'))
all_valid = sorted(glob('./*_valid.csv'))
all_test = sorted(glob('./*_test.csv'))

print(len(all_train))
print(len(all_valid))
print(len(all_test))

with open('./audio_snips_analysis.txt', 'w') as r:
    for i in range(len(all_train)):
        _, train_file = os.path.split(all_train[i])
        _, valid_file = os.path.split(all_valid[i])
        _, test_file = os.path.split(all_test[i])
        speaker_name = train_file.split('_train.csv')[0]
        
        speaker, train_cer, valid_cer, test_cer, train_wer, valid_wer, test_wer = get_res(train_file, valid_file, test_file, speaker_name)
        
        r.write('speaker {} train_cer {} valid_cer {} test_cer {} train_wer {} valid_wer {} test_wer {}\n'.format(speaker, round(train_cer, 2), round(valid_cer, 2), round(test_cer, 2), round(train_wer, 2), round(valid_wer, 2), round(test_wer, 2)))
    
    
    

exit()


train_stt = './train_stt_result.csv'

valid_stt = './valid_stt_result.csv'

test_stt = './test_stt_result.csv'

measuring(train_stt)
measuring(valid_stt)
measuring(test_stt)
